clc
close all
clear

%% Load data
data_accur_init = importdata('data\QQ0904.txt');
data_crude_init = importdata('data\QQ0929.txt');
N1 = size(data_accur_init, 1);
N2 = size(data_crude_init, 1);

%% For cases that N1 do not equal N2
data_accur = [];
data_crude = [];
for i = 1 : N1
    index = find(data_crude_init(:, 1) == data_accur_init(i, 1) &
                 data_crude_init(:, 2) == data_accur_init(i, 2));
    if (~isempty(index))
        data_accur = [data_accur; data_accur_init(i, :)];
        data_crude = [data_crude; data_crude_init(index, :)];
    end
end

%% Normalize
[data_norm, data_mean, data_std] = Normalize([data_accur;data_crude]);
N1 = size(data_accur, 1);
N2 = size(data_crude, 1);
data_norm_accur = data_norm(1 : N1, :);
data_norm_crude = data_norm(N1 + 1 : N1 + N2, :);
lambda = 637e-9;
lambda_norm = (lambda - data_mean(4)) / data_std(4);

%% Noise Estimation
noise_lambda = mean(data_norm_accur(:, 4) - data_norm_crude(:, 4));
noise_Q = mean(data_norm_accur(:, 3) - data_norm_crude(:, 3)); 

%% J1: Taken only lambda into account (Flat)
% Accurate Model
J1_accur = abs(data_norm_accur(:, 4) - lambda);
[J1_accur_sort, J1_accur_index] = sort(J1_accur);
y1_accur = (J1_accur_sort - J1_accur_sort(1)) / (J1_accur_sort(N1) - J1_accur_sort(1));
x1_accur = (0 : N1 - 1) / (N1 - 1);
figure(1);
subplot(1,3,1);
plot(x1_accur, y1_accur, 'b-'); hold on;
title('Wavelength deviation');
% Crude Model
J1_crude = abs(data_norm_crude(:, 4) - lambda);
[J1_crude_sort, J1_crude_index] = sort(J1_crude);
y1_crude = (J1_crude_sort - J1_crude_sort(1)) / (J1_crude_sort(N2) - J1_crude_sort(1));
x1_crude = (0 : N2 - 1) / (N2 - 1);
subplot(1, 3, 1);
plot(x1_crude, y1_crude, 'r-.');

%% Noise evaluation of function J1_crude
noise_J1 = noise_lambda / (J1_crude_sort(N2) - J1_crude_sort(1))

%% Only take wavelength into account (Flat type)
% OO parameters
Z1 = 8.1378;
Z2 = 0.8974;
Z3 = -1.2058;
Z4 = 6;

%% Selected set calculation
k = 1;
g = 10;
s = ceil(exp(Z1) * k^Z2 * g^Z3 + Z4);

%% Selected set number & Good enough set number mapping 
k = 1;
sg_map = zeros(1000, 2);
for g = 1:1000
    sg_map(g, :) = [ceil(exp(Z1) * k^Z2 * g^Z3 + Z4), g];
end 

s_num = 10000; % initial, a considerably large number 
sg_table = zeros(size(sg_map));
j = 1;
for i = 1:1000
    if sg_map(i, 1) ~= s_num
        s_num = sg_map(i, 1);
        sg_table(j, :) = sg_map(i, :);
        j = j + 1;
    end
end
sg_table(j:size(sg_map, 1), :) = [];
save "sg_table.txt" sg_table;
% 
% %% J2: Only use Q (Flat)
% %J2 = exp(-data_norm(:, 3));
% J2 = (-data_norm(:, 3));
% [J2_sort, J2_index] = sort(J2);
% y2 = (J2_sort - J2_sort(1)) / (J2_sort(N) - J2_sort(1));
% x2 = (0 : N - 1) / (N - 1);
% subplot(1,3,2);
% plot(x2, y2); hold on;
% title('Q-factor');
% 
% %% J3: Combine lambda and Q (Flat)
% theta = 0.9;
% J3 = theta * J1 + (1 - theta) * J2;
% [J3_sort, J3_index] = sort(J3);
% y3 = (J3_sort - J3_sort(1)) / (J3_sort(N) - J3_sort(1));
% x3 = (0 : N - 1) / (N - 1);
% subplot(1,3,3);
% plot(x3, y3); hold on;
% title('Pareto');
% 
% data = importdata('data\QQ0929.txt');
% 
% %% Normalize
% [data_norm, data_mean, data_std] = Normalize(data);
% lambda = 637e-9;
% lambda_norm = (lambda - data_mean(4)) / data_std(4);
% N = size(data, 1);
% 
% %% J1: Only use lambda (Flat)
% J1 = (data_norm(:, 4) - lambda).^2;
% [J1_sort, J1_index] = sort(J1);
% y1 = (J1_sort - J1_sort(1)) / (J1_sort(N) - J1_sort(1));
% x1 = (0 : N - 1) / (N - 1);
% figure(1);
% subplot(1,3,1);
% plot(x1, y1,'-.'); hold on;
% title('Wavelegth deviation');
% 
% %% J2: Only use Q (Flat)
% %J2 = exp(-data_norm(:, 3));
% J2 = (-data_norm(:, 3));
% [J2_sort, J2_index] = sort(J2);
% y2 = (J2_sort - J2_sort(1)) / (J2_sort(N) - J2_sort(1));
% x2 = (0 : N - 1) / (N - 1);
% subplot(1,3,2);
% plot(x2, y2,'-.'); hold on;
% title('Q-factor');
% 
% %% J3: Combine lambda and Q (Flat)
% theta = 0.9;
% J3 = theta * J1 + (1 - theta) * J2;
% [J3_sort, J3_index] = sort(J3);
% y3 = (J3_sort - J3_sort(1)) / (J3_sort(N) - J3_sort(1));
% x3 = (0 : N - 1) / (N - 1);
% subplot(1,3,3);
% plot(x3, y3,'-.'); hold on;
% title('Pareto');
% 
% 
% %% Flat type
% Z1 = 8.1378;
% Z2 = 0.8974;
% Z3 = -1.2058;
% Z4 = 6;
% 
% %% Steep Type
% % Z1 = 8.1998;
% % Z2 = 1.9164;
% % Z3 = -2.0250;
% % Z4 = 10;
% 
% k = 1;
% g = 20;
% Z = exp(Z1) * k^Z2 * g^Z3 + Z4;
% 
% s = round(Z); %Selected set number
% s_set = J1_index(1:s);
% s_set_para = data(s_set, 1:2)
